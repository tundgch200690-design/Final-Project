using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class MapManager : MonoBehaviour
{   
    public static MapManager Instance;

    [Header("Cài đặt Hệ thống")]
    public float tileSize = 2.0f;
    public int maxIterations = 500;

    [Header("Cấu hình Tile Cố định")]
    public RoomTileSO upperLanding;
    public RoomTileSO basementLanding;

    [Header("Bộ 3 Phòng Ground")]
    public RoomTileSO foyer;
    public RoomTileSO grandStaircase;
    public RoomTileSO entranceHall;

    [Header("Kho Dữ liệu Ngẫu nhiên")]
    public List<RoomTileSO> tileDeck;

    [Header("Cấu hình Generation")]
    [Tooltip("Số lần thử lại khi không tìm được bài khớp")]
    public int retryAttempts = 3;

    // Dữ liệu lưu trữ
    private Dictionary<Vector2Int, RoomTilePlacement> mapGrid = new Dictionary<Vector2Int, RoomTilePlacement>();
    private List<Vector2Int> availableSpots = new List<Vector2Int>();
    private List<RoomTileSO> remainingTiles = new List<RoomTileSO>();

    // Định nghĩa khoảng cách tầng
    private readonly Vector2Int UPPER_OFFSET = new Vector2Int(0, 50);
    private readonly Vector2Int BASEMENT_OFFSET = new Vector2Int(0, -50);

    private void Awake()
    {
        if (Instance == null) Instance = this;
        else Destroy(gameObject);
    }

    private void Start()
    {
        SetupFixedMap();
        GenerateRandomMap();
        LogMapSummary();
    }

    // --- SETUP BẢN ĐỒ ---
    private void SetupFixedMap()
    {
        if (upperLanding != null) PlaceTileLogic(UPPER_OFFSET, upperLanding, 0);
        if (basementLanding != null) PlaceTileLogic(BASEMENT_OFFSET, basementLanding, 0);

        if (grandStaircase != null) PlaceTileLogic(new Vector2Int(-1, 0), grandStaircase, 0);
        if (foyer != null) PlaceTileLogic(new Vector2Int(0, 0), foyer, 0);
        if (entranceHall != null) PlaceTileLogic(new Vector2Int(1, 0), entranceHall, 0);

        // Xóa các phòng cố định khỏi bộ bài
        if (tileDeck.Contains(upperLanding)) tileDeck.Remove(upperLanding);
        if (tileDeck.Contains(basementLanding)) tileDeck.Remove(basementLanding);
        if (tileDeck.Contains(foyer)) tileDeck.Remove(foyer);
        if (tileDeck.Contains(grandStaircase)) tileDeck.Remove(grandStaircase);
        if (tileDeck.Contains(entranceHall)) tileDeck.Remove(entranceHall);
    }

    private void GenerateRandomMap()
    {
        remainingTiles = new List<RoomTileSO>(tileDeck);

        int iterationCount = 0;
        int retryCount = 0;

        while (remainingTiles.Count > 0 && availableSpots.Count > 0 && iterationCount < maxIterations)
        {
            iterationCount++;

            if (availableSpots.Count == 0)
            {
                Debug.LogWarning("Hết chỗ trống nhưng còn bài!");
                break;
            }

            int randSpotIndex = Random.Range(0, availableSpots.Count);
            Vector2Int targetPos = availableSpots[randSpotIndex];

            FloorLayer currentLayer = DetermineFloorLayer(targetPos);
            (RoomTileSO selectedTile, int rotation) = FindMatchingTileWithRotation(targetPos, currentLayer);

            if (selectedTile != null)
            {
                PlaceTileLogic(targetPos, selectedTile, rotation);
                remainingTiles.Remove(selectedTile);
                retryCount = 0;
            }
            else
            {
                retryCount++;

                if (retryCount >= retryAttempts)
                {
                    availableSpots.RemoveAt(randSpotIndex);
                    retryCount = 0;
                }
            }
        }

        LogGenerationStats(iterationCount);
    }

    // --- API CHO PLAYER ---

    public bool HasRoom(Vector2Int coord)
    {
        return mapGrid.ContainsKey(coord);
    }

    public Vector3 GridToWorld(Vector2Int coord)
    {
        return new Vector3(coord.x * tileSize, coord.y * tileSize, -1f);
    }

    public Vector2Int WorldToGrid(Vector3 worldPos)
    {
        int x = Mathf.RoundToInt(worldPos.x / tileSize);
        int y = Mathf.RoundToInt(worldPos.y / tileSize);
        return new Vector2Int(x, y);
    }

    public RoomTileSO GetRoomTile(Vector2Int coord)
    {
        if (mapGrid.ContainsKey(coord))
            return mapGrid[coord].tile;
        return null;
    }

    // --- LOGIC CỐT LÕI ---

    private FloorLayer DetermineFloorLayer(Vector2Int pos)
    {
        if (pos.y >= UPPER_OFFSET.y - 20) return FloorLayer.Upper;
        if (pos.y <= BASEMENT_OFFSET.y + 20) return FloorLayer.Basement;
        return FloorLayer.Ground;
    }

    /// <summary>
    /// Tìm một bài khớp từ danh sách còn lại, có thể xoay
    /// </summary>
    private (RoomTileSO, int) FindMatchingTileWithRotation(Vector2Int pos, FloorLayer layer)
    {
        List<RoomTileSO> shuffledDeck = remainingTiles.OrderBy(x => Random.value).ToList();

        foreach (RoomTileSO tile in shuffledDeck)
        {
            if (!tile.CanPlaceOnFloor(layer)) continue;

            // Thử tất cả 4 hướng xoay
            for (int rotation = 0; rotation < 4; rotation++)
            {
                DoorDirection rotatedDoors = tile.RotateDoors(rotation);

                if (IsPlacementValid(pos, rotatedDoors))
                {
                    return (tile, rotation);
                }
            }
        }

        return (null, -1);
    }

    private void PlaceTileLogic(Vector2Int pos, RoomTileSO tile, int rotation)
    {
        if (mapGrid.ContainsKey(pos)) return;

        RoomTilePlacement placement = new RoomTilePlacement(tile, rotation);
        mapGrid.Add(pos, placement);

        SpawnRoomVisual(pos, placement);

        if (availableSpots.Contains(pos)) availableSpots.Remove(pos);
        UpdateAvailableSpots(pos, placement);
    }

    private void UpdateAvailableSpots(Vector2Int pos, RoomTilePlacement placement)
    {
        DoorDirection rotatedDoors = placement.GetRotatedDoors();

        CheckAndAddSpot(pos + Vector2Int.up, DoorDirection.North, rotatedDoors);
        CheckAndAddSpot(pos + Vector2Int.right, DoorDirection.East, rotatedDoors);
        CheckAndAddSpot(pos + Vector2Int.down, DoorDirection.South, rotatedDoors);
        CheckAndAddSpot(pos + Vector2Int.left, DoorDirection.West, rotatedDoors);
    }

    private void CheckAndAddSpot(Vector2Int neighborPos, DoorDirection myDoorDir, DoorDirection myRotatedDoors)
    {
        if ((myRotatedDoors & myDoorDir) == 0) return;
        if (mapGrid.ContainsKey(neighborPos)) return;
        if (!availableSpots.Contains(neighborPos)) availableSpots.Add(neighborPos);
    }

    private bool IsPlacementValid(Vector2Int pos, DoorDirection rotatedDoors)
    {
        if (!CheckConnection(pos + Vector2Int.up, DoorDirection.North, rotatedDoors)) return false;
        if (!CheckConnection(pos + Vector2Int.right, DoorDirection.East, rotatedDoors)) return false;
        if (!CheckConnection(pos + Vector2Int.down, DoorDirection.South, rotatedDoors)) return false;
        if (!CheckConnection(pos + Vector2Int.left, DoorDirection.West, rotatedDoors)) return false;
        return true;
    }

    private bool CheckConnection(Vector2Int neighborPos, DoorDirection myDir, DoorDirection myRotatedDoors)
    {
        if (!mapGrid.ContainsKey(neighborPos)) return true;

        RoomTilePlacement neighborPlacement = mapGrid[neighborPos];
        DoorDirection neighborRotatedDoors = neighborPlacement.GetRotatedDoors();
        DoorDirection neighborOppositeDir = GetOppositeDirection(myDir);

        bool iHaveDoor = (myRotatedDoors & myDir) != 0;
        bool neighborHasDoor = (neighborRotatedDoors & neighborOppositeDir) != 0;

        return iHaveDoor == neighborHasDoor;
    }

    private DoorDirection GetOppositeDirection(DoorDirection dir)
    {
        switch (dir)
        {
            case DoorDirection.North: return DoorDirection.South;
            case DoorDirection.South: return DoorDirection.North;
            case DoorDirection.East: return DoorDirection.West;
            case DoorDirection.West: return DoorDirection.East;
            default: return DoorDirection.None;
        }
    }

    private void SpawnRoomVisual(Vector2Int coord, RoomTilePlacement placement)
    {
        RoomTileSO data = placement.tile;
        int rotation = placement.rotationSteps;

        GameObject newRoomObj = new GameObject(data.roomName);
        newRoomObj.transform.position = new Vector3(coord.x * tileSize, coord.y * tileSize, 0);
        newRoomObj.transform.rotation = Quaternion.Euler(0, 0, rotation * 90f);

        SpriteRenderer sr = newRoomObj.AddComponent<SpriteRenderer>();
        if (data.roomSprite != null) sr.sprite = data.roomSprite;

        newRoomObj.AddComponent<BoxCollider2D>();

        // Debug Text
        GameObject textObj = new GameObject("Label");
        textObj.transform.SetParent(newRoomObj.transform);
        textObj.transform.localPosition = new Vector3(0, 0, -0.1f);
        TextMesh tm = textObj.AddComponent<TextMesh>();
        tm.text = $"{data.roomName}\n(R:{rotation})";
        tm.characterSize = 0.15f;
        tm.anchor = TextAnchor.MiddleCenter;
        tm.color = Color.black;

        newRoomObj.transform.SetParent(this.transform);
        newRoomObj.name = $"{data.roomName} ({coord.x},{coord.y}) [R{rotation}]";
    }

    // --- LOGGING ---

    private void LogGenerationStats(int iterationCount)
    {
        Debug.Log($"=== MAP GENERATION COMPLETE ===");
        Debug.Log($"Total Rooms Placed: {mapGrid.Count}");
        Debug.Log($"Remaining Tiles: {remainingTiles.Count}");
        Debug.Log($"Iterations Used: {iterationCount}/{maxIterations}");
        Debug.Log($"Total Deck Size: {tileDeck.Count}");
    }

    private void LogMapSummary()
    {
        if (remainingTiles.Count > 0)
        {
            Debug.LogWarning($"⚠️  {remainingTiles.Count} tiles could NOT be placed:");
            foreach (var tile in remainingTiles)
            {
                Debug.LogWarning($"   - {tile.roomName}");
            }
        }
        else
        {
            Debug.Log("✓ ALL TILES SUCCESSFULLY PLACED!");
        }
    }

#if UNITY_EDITOR
    private void OnGUI()
    {
        GUI.Label(new Rect(10, 10, 300, 60),
            $"Rooms: {mapGrid.Count}\nUnused: {remainingTiles.Count}\nSpots: {availableSpots.Count}");
    }
#endif
}